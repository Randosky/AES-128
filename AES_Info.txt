habr - https://habr.com/ru/articles/212235/
habr - https://habr.com/ru/articles/112733/
вики - https://ru.wikipedia.org/wiki/AES_(%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

Advanced Encryption Standard является стандартом, основанным на алгоритме Rijndael
AES симметричный алгоритм блочного шифрования

Block	последовательность бит, из которых состоит input, output, State и Round Key.
Также под Block можно понимать последовательность байтов

Cipher Key	секретный криптографический ключ, который используется Key Expansion процедурой,
чтобы произвести набор ключей для раундов (Round Keys);
может быть представлен как прямоугольный массив байтов, имеющий четыре строки и Nk колонок

Ciphertext	выходные данные алгоритма шифрования

Key Expansion	процедура генерации Round Keys из Cipher Key

Round Key	Round Keys получаются из Cipher Key использованием процедуры Key Expansion.
Они применяются к State при шифровании и расшифровании

State	промежуточный результат шифрования, который может быть представлен как прямоугольный массив байтов,
имеющий 4 строки и Nb колонок

S-box	нелинейная таблица замен, использующаяся в нескольких трансформациях замены байтов и
в процедуре Key Expansion для взаимнооднозначной замены значения байта.
Предварительно рассчитанный S-box можно увидеть ниже

Nb	число столбцов (32-битных слов), составляющих State. Для AES Nb = 4
Nk	число 32-битных слов, составляющих шифроключ. Для AES Nk = 4, 6, или 8
Nr	число раундов, которое является функцией Nk и Nb. Для AES Nr = 10, 12, 14

Rcon[]	массив, который состоит из битов 32-разрядного слова и является постоянным для данного раунда.
Предварительно рассчитанный Rcon[] можно увидеть ниже

Таким образом:
Block - блок шифрования с длинной 128 бит (стандарт для AES)
Key - ключ с длиной Nk = 128 бит (такую длину взяли мы, потому что с большей длинной сложнее)
Nr - число раундов = 10
Nb - число столбцов = 4 (т.к. ключ 128)

1 символ кодируем как 8 бит

Произвольный текст может не иметь длину 128 бит или кратную ей
Чтобы зашифровать текст произвольного размера нужно разбить текст на блоки по 128 бит и каждый блок зашифровать.

Стадии:

1. Инициализация
    -AddRoundKey()

2. Nr-1 раундов
    -SubBytes()
    -ShiftRows()
    -MixColumns()
    -AddRoundKey()

3. Последний раунд
    -SubBytes()
    -ShiftRows()
    -AddRoundKey()

Сначала заполняется массив State ввходными значениями по формуле State[r][c] = input[r + 4c]
r = 0,1,...,число строк = 4 => r = 0,1,2,3,4
c = 0,1,...,Nb = 4 => c = 0,1,2,3,4
То есть за раз шифруется блок размером 4х4 = 16 байт

KeySchedule[r][c] = SecretKey[r + 4c],
r = 0,1...4
c = 0,1..Nk.

Алгоритм оперирует байтами, считая их элементами конечного поля или поля Галуа GF(2^8).
Число в скобках — это количество элементов поля или его мощность.
Элементами поля GF(2^8) являются многочлены степени не более 7, которые могут быть заданы строкой своих коэффициентов.
Байт очень легко представить в виде многочлена. Например, байту {1,1,1,0,0,0,1,1}
соответствует элемент поля 1x7 + 1x6 + 1x5 + 0x4 + 0x3 + 0x2 + 1x1 + 1x0 = 1x7 + 1x6 + 1x5 + x +1.

Здесь нужно вспомнить о неработоспособности обычных правил сложения и умножения.

Новые правила:
Сложение в поле GF(28) эквивалентно операции XOR
Умножение на {01} не меняет умножаемое
Умножение на {02} производится по правилу: если умножаемое значение меньше {80}, оно сдвигается влево на 1 бит.
Если же умножаемое значение больше или равно {80}, оно сначала сдвигается влево на 1 бит,
а затем к результату сдвига применяется операция XOR со значением {1b}.
Результат может перескочить за значение {ff}, то есть за границы одного байта.
В этом случае нужно вернуть остаток от деления результата на {100}.
Умножение на другие константы можно выразить через предыдущие

MixColumns() вместе с ShiftRows() добавляют диффузию в шифр.